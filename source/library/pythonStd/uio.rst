:mod:`uio` -- 输入/输出流
==================================

.. module:: uio
   :synopsis: 输入/输出流

这个模块实现了相应 :term:`CPython` 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: `io <https://docs.python.org/3.5/library/io.html#module-io>`_

此模块包含其他类型的stream（类文件）对象和辅助函数。

概念层次
--------------------

.. admonition:: 与CPython的区别
   :class: attention

   如本节所述，MicroPython中简化了流基类的概念层次结构。

（摘要）基本流类作为所有具体类行为的基础，在CPython中遵循少量二分法（成对分类）。
在MicroPython中，它们稍微简化并隐含以实现更高的效率并节省资源。

CPython中的一个重要的二分法是无缓冲流和缓冲流。在MicroPython中，所有流目前都是无缓冲的。这
是因为所有现代操作系统，甚至许多RTOS和文件系统驱动程序都已经在他们身边执行缓冲。
添加另一层缓冲是适得其反的（一个称为“bufferbloat”的问题）并占用宝贵的内存。
请注意，仍然存在缓冲可能有用的情况，因此我们可能会在以后引入可选的缓冲支持。

但是在CPython中，另一个重要的二分法与“缓冲”相关 - 这是一个流是否可能导致短读/写。
短读取是指用户从流中请求例如10个字节，但是对于写入则类似。在CPython中，无缓冲流自动对短操作敏感，而缓冲是对它们的保证。
无短读/写是一个重要的特性，因为它允许开发更简洁和有效的程序 - 这是MicroPython非常需要的东西。
因此，虽然MicroPython不支持缓冲流，但它仍然提供非短操作流。
是否会有短期操作取决于每个特定类别的需求，但强烈建议开发人员支持非短操作行为，原因如上所述。
例如，MicroPython套接字保证避免短读/写。实际上，此时，核心中没有短操作流类的示例，并且一个是特定于端口的类，其中这种需求由硬件特性决定。

在非阻塞流的情况下，非短操作行为变得棘手，阻塞与非阻塞行为是另一个CPython二分法，完全由MicroPython支持。
非阻塞流永远不会等待数据到达或被写入 - 它们可能会读/写，或者表示缺少数据（或写入数据的能力）。
显然，这与“非短操作”策略相冲突，实际上，在CPython中，非阻塞缓冲（以及此非短操作）流的情况令人费解 - 在某些地方，这种组合是禁止的，在某些情况下它是未定义的或只是没有记录，在某些情况下它会引发冗长的异常。这个问题在MicroPython中要简单得多：非阻塞流对于高效的异步操作很重要，因此这个属性在“no-short-ops”上占优势。所以，

最后的二分法是二元对文本流。MicroPython当然支持这些，但在CPython中，文本流本身就是缓冲的，它们不在MicroPython中。
（实际上，这是我们可能会引入缓冲支持的案例之一。）

请注意，为了提高效率，MicroPython不提供与上面的层次结构相对应的抽象基类，并且不可能在纯Python中实现或子类化流类。

函数
---------

.. function:: open(name, mode='r', **kwargs)

   打开一个文件。内置 ``open()`` 函数是此函数的别名。

类
-------

.. class:: FileIO(...)

    这是以二进制模式打开的文件类型，例如使用 ``open(name, "rb")`` 
    您不应该直接实例化这个类。

.. class:: TextIOWrapper(...)

    这是在文本模式下打开的文件类型，例如使用 ``open(name, "rt")`` 。
    您不应该直接实例化这个类。

.. class:: StringIO([string])

.. class:: BytesIO([string])


    用于输入/输出的内存文件类对象。 ``StringIO`` 用于文本模式I / O（类似于使用“t”修饰符打开的普通文件）。``BytesIO`` 用于二进制模式I ​​/ O（类似于使用“b”修饰符打开的普通文件）。可以使用字符串参数指定类文件对象的初始内容（应为普通字符串StringIO或字节对象BytesIO）。
    所有常见的文件的方法，如 ``read()`` ， ``write()`` ， ``seek()`` ， ``flush()`` ， ``close()``  在这些对象上可用以下的方法:


    .. method:: getvalue()

       获取保存数据的底层缓冲区的当前内容。


.. class:: StringIO(alloc_size)
.. class:: BytesIO(alloc_size)

    创建一个空 `StringIO`/ `BytesIO` 对象，预分配以容纳 *alloc_size* 字节数。这意味着写入该字节数不会导致缓冲区的重新分配，因此不会出现内存不足或导致内存碎片的情况。
    这些构造函数是MicroPython扩展，建议仅用于特殊情况和系统级库，而不是最终用户应用程序。

    .. admonition:: Difference to CPython
        :class: attention

        这些构造函数是MicroPython扩展。
