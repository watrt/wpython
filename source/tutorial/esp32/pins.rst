GPIO 引脚
=========

将您的板与真实世界相连、并控制其他器件的方式即通过GPIO引脚。并非所有引脚都可用，多数情况下，可用引脚为: 

0, 2, 4, 5, 12, 13, 14, 15, 16, 17, 18, 19, 
21, 22, 23, 25, 26, 27, 32, 33, 34, 35, 36，39. 

GPIO0 和 GPIO2 为strapping引脚，这类引脚可影响启动。

GPIO1和GPIO3分别为REPL UART TX和RX。

GPIO6-11通常用于SPI Flash。

GPIO34-39 只能设置为输入模式，且无软件上拉和下拉函数。

GPIO37-38连接到一个用作ADC PRE_AMP的电容。

Strapping 引脚
--------------

芯片系统重置（电源复位、RTC监控复位和欠压复位）的过程中，strapping引脚的锁存器将电压等级作为"0"或"1"的strapping位取样，
并保持这些数据直至芯片断电或关闭。Strapping 配置设备的启动模式、VDD_SDIO的运行电压和其他初始系统设置。

内置 LDO 电压 (VDD_SDIO)
+------------------------+------------+----------+----------+
|         Pin            |  Default   |   3.3V   |   1.8V   |
+========================+============+==========+==========+
|       GPIO12 MTDI      |  Pull-down |    0     |    1     |
+------------------------+------------+----------+----------+

注意: 你可以使用 `espefuse.py set_flash_voltage 3.3V` 来忽略 MTDI 引脚 (GPIO12) 对于 VDD_SDIO 的影响。
https://github.com/espressif/esptool/wiki/espefuse

启动模式
+------------------------+------------+----------+----------+
|         Pin            |  Default   | SPI Boot | Download Boot   |
+========================+============+==========+==========+
|         GPIO0          |  Pull-up   |    1     |    0     |
+------------------------+------------+----------+----------+
|         GPIO2          | Pull-down  |Don’t-care|    0     |
+------------------------+------------+----------+----------+

因此我们建议只将其用于输出，或确保启动时下拉（上拉）不受影响。

引脚在 machine 模块中, 确保首先 import 了machine 模块。然后使用一下代码创建一个Pin对象::

    >>> pin = machine.Pin(4)

此处，"4"为您想访问的引脚。通常您要将引脚配置为输入或输出，且需在创建时完成配置。使用以下指令创建一个输出引脚::

    >>> pin = machine.Pin(4, machine.Pin.IN, machine.Pin.PULL_UP)

您可在使用PULL_UP或 None 来配置拉电阻。若未指定，则默认为None（并非拉电阻）。您可使用以下方法读取引脚上的值::

    >>> pin.value()
    0

此处您的板上的引脚可能回返回0或1，这取决于其连接的电路。使用以下指令创建一个输出引脚::

    >>> pin = machine.Pin(4, machine.Pin.OUT)

用以下方法设置引脚值::

    >>> pin.value(0)
    >>> pin.value(1)

或::

    >>> pin.off()
    >>> pin.on()

外部中断
-------------------

所有引脚都配置为在输入更改的情况下触发硬件中断。您可将代码（回调函数）设置为在触发时执行。

首先定义一个回调函数，此函数须用一个单独参数，即触发此函数的引脚。我们将使此函数设计为仅打印引脚::

    >>> def callback(p):
    ...     print('pin change', p)


下一步我们将创建两个引脚并将其配置为输入::

    >>> from machine import Pin
    >>> p4 = Pin(4, Pin.IN)
    >>> p5 = Pin(5, Pin.IN)

最后，我们需要确定引脚何时触发，以及检测事件时调用的函数::

    >>> p4.irq(trigger=Pin.IRQ_FALLING, handler=callback)
    >>> p5.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=callback)

我们将引脚4设置为仅在输入的下降沿触发（当其由高到低），将引脚5设置为在上升沿和下降沿都触发。
输入此代码后，您可将高电压和低电压用于引脚4和5，以观察中断的执行。

事件一旦发生，即将触发一个硬中断，并将中断所有运行代码，包括Python代码。
因此，您的回调函数在其所能做的事情中（例如，此函数无法分配内存）存在局限性，且函数应尽可能短小简易。

